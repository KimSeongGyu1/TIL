# 운영체제와 정보기술의 원리(반효경)

### 6장(CPU 스케줄링)

<details>
  <summary> 기계어 명령들 </summary>
  </br>
  <p>기계어 명령은 크게 CPU 내에서 수행되는 명령, 메모리 접근을 필요로 하는 명령, 입출력을 동반하는 명령으로 나누어볼 수 있다</p>
  <details>
    <summary> CPU 내에서 수행되는 명령 </summary>
      </br>
      <p>CPU 내의 레지스터에 있는 두 값을 더해 레지스터에 저장하는 Add 명령이 있다</p>
      <p>CPU 내에서만 수행되므로 수행속도가 매우 빠르다</p>
  </details>
  <details>
    <summary> 메모리 접근을 필요로 하는 명령 </summary>
      </br>
      <p>Load 명령과 Store 명령이 있다</p>
      <p>Load는 메모리에 있는 데이터를 CPU로 읽어오며, Store는 CPU에서 계산된 값을 메모리에 저장한다</p>
      <p>CPU 내에서 수행되는 명령보다는 오래 걸리지만, 비교적 짧은 시간에 수행된다</p>
  </details>
  <details>
    <summary> 입출력을 동반하는 명령 </summary>
      </br>
      <p>키보드, 화면, 디스크 등에 입출력하는 것들이 있다</p>
      <p>나머지 두 가지에 비해 대단히 오랜 시간이 소요된다</p>
      <p>모든 입출력 명령은 특권명령으로 사용자 프로그램이 직접 수행할 수 없다</p>
  </details>
</details>
<hr>

<details>
  <summary> CPU 버스트와 I/O 버스트 </summary>
  </br>
  <p>사용자 프로그램은 CPU 작업과 I/O 작업의 반복으로 구성된다</p>
  <p>사용자 프로그램이 CPU를 직접 가지고 빠른 명령을 수행하는 일련의 단계를 CPU 버스트라 한다</p>
  <p>I/O 요청이 발생해 커널에 의해 입출력 작업을 수행하는 비교적 느린 단계를 I/O 버스트라 한다</p>
  <p>버스트의 비중에 따라 CPU 바운드 프로세스 또는 I/O 바운드 프로세스로 프로세스를 나눌 수 있다</p>
</details>
<hr>

<details>
  <summary> CPU 스케줄링의 필요성 </summary>
  </br>
  <p>CPU 바운드 프로세스와 I/O 바운드 프로세스들이 동일한 시스템 내부에서 균형있게 사용되기 위해 CPU 스케줄링이 필요하다</p>
  <p>일반적으로 I/O 바운드 프로세스는 사용자와 상호작용을 하며 빠른 응답을 필요로 하기 때문에 우선순위가 높을 필요가 있다</p>
  <p>이는 CPU를 짧게 사용하고 다음 I/O 작업을 곧바로 수행하게 해주면서 I/O 장치의 이용률도 높이는 효과를 낼 수 있다</p>
  <p>CPU 바운드 프로세스가 우선적이게 되면 I/O 프로세스는 비교적 긴 휴면 상태를 겪으며 비효율적이 될 수 있다</p>
</details>
<hr>

<details>
  <summary> CPU 스케줄러 </summary>
  </br>
  <p>CPU 스케줄러는 준비 상태에 있는 프로세스들 중 어떠한 프로세스에게 CPU를 할당할지 결정하는 운영체제의 코드이다</p>
  <details>
    <summary> CPU 스케줄러가 호출되는 경우 </summary>
    </br>
    <p>(1)실행 상태에 있던 프로세스가 I/O 요청등에 의해 봉쇄(blocked) 상태로 바뀌는 경우</p>
    <p>(2)실행 상태에 있던 프로세스가 타이머 인터럽트에 의해 준비 상태로 바뀌는 경우</p>
    <p>(3)I/O 요청으로 봉쇄 상태에 있던 프로세스의 I/O 작업이 완료되어 인터럽트가 발생하고 준비 상태로 바뀌는 경우</p>
    <p>(4)CPU에서 실행 상태에 있는 프로세스가 종료되는 경우</p>
  </details>
  <p>CPU 스케줄링 방식에는 비선점형(nonpreemptive)방식과 선점형(preemptive) 방식이 있다</p>
  <p>비선점형 방식에서는 프로세스는 스스로 반납하기 전까지 CPU를 빼앗기지 않는다</p>
  <p>선점형 방식에서는 프로세스의 CPU 점거를 강제로 빼앗을 수 있다</p>
  <p>호출되는 경우에서 (1)과 (4)가 비선점형 스케줄링의 예시이며, (2)와 (3)이 선점형 스케줄링의 예이다</p>
</details>
<hr>

<details>
  <summary> 디스패처 </summary>
  </br>
  <p>CPU 스케줄러가 어떤 프로세스에게 CPU를 할당할지 결정하고 난 후 새로운 프로세스가 CPU를 할당받고 작업을 수행할 수 있도록 환경설정을 하는 운영체제의 코드를 디스패처(dispatcher)라고 부른다</p>
  <p>디스패처는 수행 중이던 프로세스의 문맥을 PCB에 저장하고 새롭게 선택된 프로세스의 문맥을 PCB로부터 복원한 후 CPU를 넘기는 작업을 수행한다</p>
  <p>디스패처가 하나의 프로세스를 정지시키고 다른 프로세스에게 CPU를 전달하기까지 걸리는 시간을 디스패치 지연시간(dispatch latency)이라 하며 디스패치 지연시간의 대부분은 문맥교환 오버헤드에 해당한다</p>
</details>
<hr>

<details>
  <summary> 스케줄링의 성능평가 </summary>
  </br>
  <details>
    <summary> 시스템 관점의 지표 </summary>
    </br>
    <p>CPU 이용률과 처리량</p>
    <p>CPU 이용률은 전체 시간 중에 CPU가 일을 한 시간의 비율이다</p>
    <p>처리량은 주어진 시간동안 준비 큐에서 기다리고 있는 프로세스 중 몇 개를 끝마쳤는지를 나타낸다</p>
  </details>
  <details>
    <summary> 사용자 관점의 지표 </summary>
    </br>
    <p>소요시간, 대기시간, 응답시간 등 시간과 관련된 지표들</p>
    <p>소요시간은 프로세스가 CPU를 요청한 시점부터 CPU 버스트가 끝날 때까지 걸린 시간이다</p>
    <p>대기시간은 CPU 버스트 기간 중 프로세스가 준비 큐에서 CPU를 얻기 위해 기다린 시간의 합을 뜻한다</p>
    <p>시분할 시스템에서는 한 번의 CPU 버스트 중에서도 준비 큐에서 기다린 시간이 여러번 발생할 수 있다</p>
    <p>응답시간은 프로세스가 준비 큐에 들어온 후 첫번째 CPU를 획득하기까지 기다린 시간을 뜻한다</p>
  </details>
</details>
<hr>

<details>
  <summary> 선입선출(FCFS: First Come First Served) 스케줄링 </summary>
  </br>
  <p>프로세스가 준비 큐에 도착한 순서대로 CPU를 할당한다</p>
  <p>자발적으로 CPU를 반납할 때까지 빼앗지 않는다</p>
  <p>CPU 버스트가 짧은 프로세스가 CPU 버스트가 긴 프로세스보다 나중에 도착해 오랜 시간을 기다려야 하는 현상을 콘보이 현상이라 하며 FCFS의 대표적인 단점이다</p>
</details>
<hr>

<details>
  <summary> 최단작업 우선(SJF: Shortest Job First) 스케줄링 </summary>
  </br>
  <p>CPU 버스트가 가장 짧은 프로세스에게 제일 먼저 CPU를 할당한다</p>
  <p>평균 대기시간을 가장 짧게 하는 알고리즘으로 알려져 있다</p>
  <p>비선점형과 선점형 두 가지로 구현될 수 있다</p>
  <p>현재 실행중인 프로세스보다 더 짧은 CPU 버스트가 도착할 경우 CPU를 뺏는 선점형 방식은 SRTF(Shortest Remaining Time First)라고도 부른다</p>
  <p>평균 대기시간을 최소화하는 알고리즘이긴 하지만 평균을 줄이는 것이 항상 좋다고는 할 수 없다</p>
  <p>CPU 버스트가 긴 프로세스는 영원히 기다리기만 할 수도 있다. 이와 같은 현상을 기아 현상이라 하며 SJF의 심각한 문제점이다</p>
</details>

<details>
  <summary> 우선순위(priority) 스케줄링 </summary>
  </br>
  <p>준비 큐에서 기다리는 프로세스들에 우선순위를 부여하고 이에 따라 처리한다</p>
  <p>우선순위는 여러가지 지표로 결정할 수 있다</p>
  <p>선점형 방식과 비선점형 방식으로 각각 구현 가능하다</p>
  <p>SJF와 마찬가지로 기아현상이 발생할 수 있다</p>
  <p>기아현상을 해결하기 위해 기다릴 수록 우선순위를 조금씩 높이는 노화(aging) 기법을 사용할 수 있다</p>
</details>

<details>
  <summary> 라운드 로빈(Round Robin) 스케줄링 </summary>
  </br>
  <p>지금까지 소개한 스케줄링 방식과 다르게 시분할 시스템의 성질을 가장 잘 활용한 스케줄링 방식이다</p>
  <p>기본적인 목적은 짧은 CPU 버스트 프로세스에게 빠르게 CPU를 얻게 해주며 긴 CPU 버스트 프로세스가 불이익을 당하지 않게 해주는 것이다</p>
  <p>각 프로세스가 CPU를 연속적으로 사용할 수 있는 시간이 특정 시간으로 제한된다</p>
  <p>제한 시간이 끝나면 프로세스는 CPU를 양보하고 준비 큐의 제일 뒤에 줄을 선다</p>
  <p>각 프로세스가 사용할 수 있는 최대 시간을 할당시간(time quantum)이라 부른다</p>
  <p>할당시간이 너무 길면 FCFS와 같은 결과가 나올 수 있지만, 너무 짧으면 문맥 교환의 오버헤드가 커진다</p>
</details>

<details>
  <summary> 멀티레벨 큐 </summary>
  </br>
  <p>준비큐를 여러 개로 분할해 관리하는 기법이다</p>
  <p>어떤 준비큐에 우선적으로 CPU를 할당할 것인가, 프로세스를 어떤 준비 큐에 넣어야 할 것인가에 대한 로직이 필요하다</p>
  <p>일반적으로 빠른 응답을 필요로 하는 프로세스들과 나머지들을 나누어 관리한다</p>
  <p>사용자 상호작용을 담기 위한 전위 큐(foreground queue)와 계산 위주의 작업을 담기 위한 후위 큐(background queue)로 분할 된다</p>
  <p>전위 큐에서는 짧은 응답시간을 위해 라운드 로빈을 사용하며 후위큐에서는 FCFS를 이용해 문맥교환 오버헤드를 줄이도록 한다</p>
  <p>큐 끼리의 우선순위를 나누는 것은 고정 우선순위 방식과 타임 슬라이스 방식으로 나눌 수 있다</p>
  <p>고정 우선순위 방식은 항상 전위큐를 우선적으로 수행하며, 타임 슬라이스 방식은 각 큐에 시간을 적절한 비율로 할당한다</p>
</details>

<details>
  <summary> 멀티레벨 피드백 큐 </summary>
  </br>
  <p>멀티레벨 큐 방식에서 프로세스가 다른 큐로 이동가능한 방식이다</p>
  <p>우선순위가 낮은 큐에서 오래 기다렸으면 우선순위가 높은 큐로 옮길 수 있다</p>
</details>

<details>
  <summary> 다중처리기(multi processor) 스케줄링 </summary>
  </br>
  <p>CPU가 여러 개이면 CPU가 하나일 때 보다 문제가 복잡해진다</p>
  <p>CPU별 부하가 적절히 분산되도록 하는 부하균형(load balancing) 메커니즘을 필요로 한다</p>
  <p>대칭형 다중처리와 비대칭형 다중처리로 나눌 수도 있다</p>
</details>

<details>
  <summary> 실시간 스케줄링 </summary>
  </br>
  <p>각 작업마다 반드시 주어진 데드라인 안에 작업을 처리해야 하는 시스템이다</p>
  <p>경성 실시간 시스템(hard real time system)과 연성 실시간 시스템(soft real time system)으로 나눌 수 있다</p>
  <p>경성은 무슨 일이 있어도 데드라인을 지켜야 하는 것이고 연성은 지켜야 하지만 경성만큼 위험하지는 않은 것이다</p>
  <p>데드라인이 얼마남지 않은 요청을 먼저 처리하는 EDF(Earlist Deadline First)를 널리 사용한다</p>
</details>

<details>
  <summary> 스케줄링 알고리즘의 평가 </summary>
  </br>
  <p>큐잉모델, 시뮬레이션, 구현 및 실측 등 여러가지 방식으로 스케줄링 알고리즘을 평가할 수 있다</p>
  <p>큐일모델은 주로 이론가들이 수행하며 수학적 계산을 통해 각종 성능지표를 구한다</p>
  <p>구현 및 실측은 주로 구현가들이 수행하며 직접 구현해보고 실제로 측정해본다</p>
  <p>시뮬레이션은 실제 시스템에 구현해 수행하지 않고 가상으로 확인하는 방법이다.</p>
</details>